[{"name":"App.R","content":"library(shiny)\nlibrary(ggplot2)\nlibrary(plotly)      # WICHTIG: Für Interaktivität\nlibrary(munsell)     # WICHTIG: Fix für den \"Weißen Bildschirm\" Fehler (ggplot Dependency)\nlibrary(htmlwidgets) # WICHTIG: Hilft bei der Darstellung von Plotly in Shinylive\n\n# --- GLOBALE KONFIGURATION ---\ncuts_vdec <- seq(0, 60, by = 10)\ncustom_colors <- c(\"seagreen3\", \"palegreen1\", \"palegoldenrod\", \"salmon1\", \"firebrick3\", \"darkred\")\n\n# ==============================================================================\n# MODUL UI DEFINITION (Das Layout für EINEN Athleten)\n# ==============================================================================\nathleteUI <- function(id) {\n  # ns (namespace) sorgt dafür, dass die IDs (z.B. \"v1RM\") pro Tab einzigartig bleiben\n  ns <- NS(id)\n  \n  sidebarLayout(\n    sidebarPanel(\n      # Input für den Athletennamen\n      textInput(ns(\"athleteName\"), \"Athlete Name:\", value = \"Test Person\"),\n      \n      # Input for the 1RM velocity\n      numericInput(ns(\"v1RM\"), \"Enter the velocity at 1RM (v1RM) in m/s:\", value = 0.2, min = 0, step = 0.01),\n      \n      # Inputs for Weight (kg) and Velocity (m/s) for up to 10 data points\n      h4(\"Enter Weight and Velocity Data:\"),\n      \n      fluidRow(\n        column(2, h5(\"Set\")),  \n        column(5, h5(\"Weight (kg)\")),\n        column(5, h5(\"Velocity (m/s)\"))\n      ),\n      \n      # Generiere die 10 Eingabezeilen\n      lapply(1:10, function(i) {\n        fluidRow(\n          column(2, h5(i)), \n          column(5, numericInput(ns(paste0(\"weight_\", i)), label = NULL, \n                                 value = c(20, 70, 100, 125, 145, NA, NA, NA, NA, NA)[i], \n                                 min = 0, step = 0.01)),\n          column(5, numericInput(ns(paste0(\"velocity_\", i)), label = NULL, \n                                 value = c(1.5, 1.1, 0.83, 0.59, 0.41, NA, NA, NA, NA, NA)[i], \n                                 min = 0, step = 0.01))\n        )\n      }),\n      \n      actionButton(ns(\"calcButton\"), \"Calculate e1RM\")\n    ),\n    \n    mainPanel(\n      verbatimTextOutput(ns(\"plot_info\")),\n      \n      # WICHTIG: plotlyOutput statt plotOutput für Interaktivität\n      plotlyOutput(ns(\"plot\"), height = \"500px\"),\n      \n      br(), hr(),\n      \n      h4(\"Individualized Training Interface\"),\n      fluidRow(\n        column(6, \n               numericInput(ns(\"calc_load\"), \"Enter Training Load (kg)\", value = 120, min = 0, step = 1),\n               sliderInput(ns(\"vd_slider\"), \"Velocity Decrement (%)\", \n                           min = 0, max = 100, value = 20, step = 1)\n        ),\n        column(6,\n               verbatimTextOutput(ns(\"vd_output\")),\n               br(),\n               checkboxInput(ns(\"show_zones\"), HTML(\"Display V<sub>dec<\/sub> Zones\"), value = FALSE),\n               checkboxInput(ns(\"show_individual\"), HTML(\"Display V<sub>dec<\/sub> Slider\"), value = FALSE)\n        )\n      ),\n      \n      hr(),\n      \n      fluidRow(\n        column(6, h4(\"Measured Data\"), tableOutput(ns(\"summaryTable\"))),  \n        column(6, h4(\"Predictions\"), tableOutput(ns(\"percentTable\")))   \n      )\n    )\n  )\n}\n\n# ==============================================================================\n# MODUL SERVER DEFINITION (Die Logik für EINEN Athleten)\n# ==============================================================================\nathleteServer <- function(id) {\n  moduleServer(id, function(input, output, session) {\n    \n    # EventReactive to trigger calculation only after button is pressed\n    calculate <- eventReactive(input$calcButton, {\n      df <- data.frame(Weight = numeric(0), Velocity = numeric(0))\n      \n      # Loop through the inputs\n      for (i in 1:10) {\n        weight <- input[[paste0(\"weight_\", i)]]\n        velocity <- input[[paste0(\"velocity_\", i)]]\n        \n        if (!is.na(weight) && !is.na(velocity)) {\n          df <- rbind(df, data.frame(Weight = weight, Velocity = velocity))\n        }\n      }\n      \n      if (nrow(df) >= 2) {\n        return(df)\n      } else {\n        return(NULL)\n      }\n    })\n    \n    # Regression Logic\n    regression <- reactive({\n      df <- calculate()\n      if (!is.null(df)) {\n        fit <- lm(Velocity ~ Weight, data = df)\n        slope <- coef(fit)[\"Weight\"]\n        intercept <- coef(fit)[\"(Intercept)\"]\n        r_squared <- summary(fit)$r.squared\n        \n        target_v <- if (!is.na(input$v1RM)) input$v1RM else 0\n        max_load <- (target_v - intercept) / slope\n        \n        return(list(\n          slope = slope, \n          intercept = intercept, \n          r_squared = r_squared, \n          r2 = r_squared,        \n          max_load = max_load,   \n          model = fit, \n          df = df\n        ))\n      }\n      return(NULL)\n    })\n    \n    # Plot Info Output\n    output$plot_info <- renderPrint({\n      reg <- regression()\n      req(reg)\n      \n      cat(\n        \"Regression Results:\\n\",\n        \"---------------------------\\n\",\n        \"estimated 1RM:       \", sprintf(\"%.2f\", reg$max_load), \" kg\\n\",\n        \"R²:                  \", sprintf(\"%.3f\", reg$r2), \"\\n\",\n        \"Slope:               \", sprintf(\"%.4f\", reg$slope), \"\\n\",\n        \"v0 (Intercept):      \", sprintf(\"%.2f\", reg$intercept), \" m/s\\n\",\n        sep = \"\"\n      )\n    })\n    \n    # Velocity Decrement Output\n    output$vd_output <- renderPrint({\n      reg <- regression()\n      req(reg)\n      req(input$calc_load) \n      \n      e1RM_val <- (input$v1RM - reg$intercept) / reg$slope\n      start_vel <- reg$intercept + reg$slope * input$calc_load\n      perc_start <- (input$calc_load / e1RM_val) * 100\n      stop_vel <- start_vel * (1 - (input$vd_slider / 100))\n      \n      cat(\n        \"Absolute Load:               \", input$calc_load, \" kg\\n\",\n        \"Relative Load:               \", sprintf(\"%.1f\", perc_start), \" %\\n\",\n        \"Initial Velocity:            \", sprintf(\"%.2f\",start_vel), \" m/s\\n\",\n        \"Terminal Velocity(\", input$vd_slider, \"% loss): \", sprintf(\"%.2f\", stop_vel), \" m/s\",\n        sep = \"\"\n      )\n    })\n    \n    # Plot Logic (JETZT MIT PLOTLY)\n    output$plot <- renderPlotly({\n      reg <- regression()\n      \n      if (!is.null(reg) && !is.na(input$v1RM)) {\n        df <- reg$df\n        e1RM <- (input$v1RM - reg$intercept) / reg$slope\n        x_max <- ceiling(e1RM / 10) * 10  \n        \n        plot_title <- \"Load-Velocity Profile\"\n        if (input$athleteName != \"\") {\n          plot_title <- paste0(\"Load-Velocity Profile - \", input$athleteName)\n        }\n        \n        # WICHTIG: text Aesthetic für Hover-Info hinzufügen\n        p <- ggplot(df, aes(x = Weight, y = Velocity))\n        \n        # --- ZONES ---\n        if(input$show_zones && !is.na(input$calc_load)){\n          v_start <- reg$intercept + reg$slope * input$calc_load\n          v_bounds <- v_start * (1 - cuts_vdec / 100)\n          \n          # ANPASSUNG FÜR LEGENDE: Labels generieren\n          zone_labels <- paste0(head(cuts_vdec, -1), \"-\", tail(cuts_vdec, -1), \"%\")\n          \n          # Fix für Plotly: Unendliche Werte (Inf) funktionieren manchmal nicht gut im Browser\n          # Wir nutzen x_max + Puffer statt Inf für die Rechtecke\n          rect_data <- data.frame(\n            ymin = v_bounds[-1],              \n            ymax = v_bounds[-length(v_bounds)],  \n            Zone = factor(zone_labels, levels = zone_labels) # Faktor für korrekte Legenden-Reihenfolge\n          )\n          \n          p <- p + geom_rect(\n            data = rect_data,\n            # Nutze min(Weight) und x_max statt -Inf/Inf für bessere Plotly Kompatibilität\n            # fill = Zone sorgt für die Legende\n            aes(xmin = 0, xmax = x_max + 10, ymin = ymin, ymax = ymax, fill = Zone),\n            inherit.aes = FALSE,\n            alpha = 0.5 \n          ) +\n            scale_fill_manual(values = custom_colors, name = HTML(\"V<sub>dec<\/sub>\")) + \n            geom_hline(yintercept = v_start, linetype = \"solid\", color = \"black\", linewidth = 0.5)\n        }\n        \n        # --- INDIVIDUAL SLIDER ---\n        if(input$show_individual && !is.na(input$calc_load)){\n          start_load <- input$calc_load\n          start_vel <- reg$intercept + reg$slope * start_load\n          target_vel <- start_vel * (1 - input$vd_slider / 100)\n          \n          # HINWEIS: Annotate Segments funktionieren in Plotly, aber wir fügen Tooltips hinzu\n          p <- p + \n            geom_point(data=data.frame(x=start_load, y=target_vel+0.023), \n                       aes(x=x, y=y, text=paste(\"Training Load:\", x, \"kg\")), \n                       color = \"blue\", size = 3, shape = 25, fill = \"blue\", inherit.aes = FALSE) +\n            annotate(\"segment\", x = start_load, xend = start_load, y = start_vel, yend = target_vel,\n                     color = \"blue\", linewidth = 0.7, linetype = \"solid\") \n        }\n        \n        # Base Plot Aufbau\n        p <- p +\n          # Datenpunkte mit Custom Tooltip\n          geom_point(aes(text = paste(\"Weight:\", Weight, \"kg<br>Velocity:\", Velocity, \"m/s\")), \n                     color = \"red\", size = 2) + \n          \n          # Regressionslinie\n          geom_smooth(method = \"lm\", se = FALSE, formula = y ~ x, color = \"black\", linetype = \"dashed\", linewidth = 0.7) + \n          \n          # e1RM Punkt mit Custom Tooltip\n          geom_point(data = data.frame(x = e1RM, y = input$v1RM), \n                     aes(x = x, y = y, text = paste(\"Estimated 1RM:\", round(x, 2), \"kg\")), \n                     color = \"black\", size = 2.5, shape = 18, inherit.aes = FALSE) + \n          \n          labs(title = plot_title, \n               x = \"Weight (kg)\", \n               y = \"Velocity (m/s)\") +\n          # HIER WURDE DER EXPAND FIX WIEDER EINGEBAUT\n          scale_x_continuous(breaks = seq(0, x_max + 20, by = 20), \n                             limits = c(0, x_max + 10),\n                             expand = c(0, 0)) + \n          scale_y_continuous(breaks = seq(0, max(df$Velocity, na.rm = TRUE)+0.2, by = 0.1),\n                             limits = c(0, max(df$Velocity, na.rm = TRUE)+0.2),\n                             expand = c(0, 0)) +\n          theme_classic() +\n          theme(\n            plot.title = element_text(size = 14, face = \"bold\"),\n            axis.title = element_text(face = \"italic\", size = 10)\n          ) \n        \n        # Umwandlung in Plotly Objekt\n        # tooltip = \"text\" sorgt dafür, dass nur unsere definierten Text-Felder angezeigt werden\n        ggplotly(p, tooltip = \"text\") %>%\n          config(displayModeBar = TRUE,  # Leiste anzeigen für Download/Snapshot\n                 displaylogo = FALSE,    # Plotly Logo ausblenden\n                 modeBarButtonsToRemove = c(\"lasso2d\", \"select2d\")) # Unnötige Tools entfernen\n      }\n    })\n    \n    # Table 1\n    output$summaryTable <- renderTable({\n      reg <- regression()\n      if (!is.null(reg) && !is.na(input$v1RM)) {\n        e1RM <- (input$v1RM - reg$intercept) / reg$slope\n        df <- reg$df\n        df$`% of e1RM` <- sprintf(\"%.1f\",round((df$Weight / e1RM) * 100, 1))\n        return(df)\n      } else {\n        return(NULL)\n      }\n    })\n    \n    # Table 2\n    output$percentTable <- renderTable({\n      reg <- regression()\n      if (!is.null(reg) && !is.na(input$v1RM)) {\n        e1RM <- (input$v1RM - reg$intercept) / reg$slope\n        percentages <- c(50, 60, 70, 75, 80, 85, 90, 95)\n        weights <- e1RM * (percentages / 100) \n        velocities <- reg$intercept + reg$slope * weights \n        \n        df_percent <- data.frame(\n          Percent = sprintf(\"%.0f\", percentages),\n          Weight = sprintf(\"%.1f\",round(weights, 1)),\n          Velocity = round(velocities, 2)\n        )\n        return(df_percent)\n      } else {\n        return(NULL)\n      }\n    })\n  })\n}\n\n# ==============================================================================\n# MAIN APP (Zusammensetzen der Module)\n# ==============================================================================\n\nui <- fluidPage(\n  # --- 1. DER PASSWORTSCHUTZ (Start) ---\n  tags$head(tags$script(HTML('\n    var password = \"LightWeightBaby\"; \n    \n    var input = prompt(\"Bitte Passwort eingeben / Please enter password:\");\n    if (input != password) {\n      document.body.innerHTML = \"<div style=\\'text-align:center; margin-top: 50px; font-family: sans-serif;\\'><h1>Zugriff verweigert / Access Denied<\/h1><p>Incorrect password.<\/p><\/div>\";\n      throw new Error(\"Falsches Passwort - Zugriff gestoppt.\");\n    }\n  '))),\n  # --- DER PASSWORTSCHUTZ (Ende) ---\n  titlePanel(\"1-RM Estimator - Multi Athlete\"),\n  \n  # Hier erstellen wir dynamisch 12 Tabs\n  do.call(tabsetPanel, lapply(1:12, function(i) {\n    tabPanel(\n      title = paste(\"Athlete\", i), \n      # Aufruf der Modul-UI mit eindeutiger ID (z.B. \"athlete_1\")\n      athleteUI(paste0(\"athlete_\", i))\n    )\n  }))\n)\n\nserver <- function(input, output, session) {\n  # Hier rufen wir dynamisch 12 mal die Server-Logik auf\n  lapply(1:12, function(i) {\n    # Aufruf des Modul-Servers mit der gleichen ID wie in der UI\n    athleteServer(paste0(\"athlete_\", i))\n  })\n}\n\nshinyApp(ui, server)","type":"text"}]
